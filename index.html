<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Adam Schroder »» Designer in Berlin</title>
		<meta charset="utf-8">
		<link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans" rel="stylesheet">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#fafafa;
				padding:0;
				margin:0;
				font-weight: bold;
				overflow:hidden;
			}

			.headline {
				font-family: 'Roboto Mono', monospace;
			}

			h1 {
				font-size: 32px;
				margin:0;
				position: absolute;
			}

			.top-mark {
				display: block;
				height: 45px;
				color: #6b6b6b;
				padding:20px 20px 20px 40px;
			}

			.mark {
				display: inline-block;
				overflow: hidden;
				cursor:default;
			}

			.line {
				padding-left: 5px;
				width: 12px;
				padding: 0;
				transform: rotateY(180deg);
			}

			.name {
				display: inline-block;
				width: 0px;
				overflow: hidden;
				color:#333;
				-webkit-transition: width 500ms cubic-bezier(0.785, 0.135, 0.15, 0.86);
  				transition: width 500ms cubic-bezier(0.785, 0.135, 0.15, 0.86); 
				cursor:default;
			}

			.top-mark:hover .name {
				width: 80px;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				color: #ffffff;
				padding: 5px;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				z-index:1000;
			}

			a {
				color: #ffffff;
			}

			.title {
				font-family: Arial,sans-serif;
				font-size: 14px;
				line-height: 20px;
				color: #333;
			}

			.sub-heading {
				font-family: 'IBM Plex Sans', sans-serif;
				color: #888;
				font-size: 26px;
				line-height: 40px;
				font-weight: 200;
			}

			#webglmessage a { color:#da0 }
		</style>
	</head>
	<body>
		<h1 class="headline top-mark"><div class="mark">/</div><div class="name">Adam</div><div class="mark line">|</div></h1>

        <script src="js/three.js"></script>
        <script src="js/effects/ParallaxBarrierEffect.js"></script>
		<script src="js/WebGL.js"></script>
		<script src="js/shaders/CopyShader.js"></script>
		<script>

			if ( WEBGL.isWebGLAvailable() === false ) {
				document.body.appendChild( WEBGL.getWebGLErrorMessage() );
			}

			let container, camera, scene, renderer, effect, raycaster, ring, canvas;
			let spheres = [];
			let rotations = [];

			let mouse = new THREE.Vector2(), INTERSECTED;

			let mouseX = 0;
			let mouseY = 0;


			let windowHalfX = window.innerWidth / 2;
			let windowHalfY = window.innerHeight / 2;

			document.addEventListener( 'mousemove', onDocumentMouseMove, false );

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 100 );
				camera.position.z = 20;
				camera.focalLength = 3;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xFAFAFA );

				let geometry = new THREE.IcosahedronBufferGeometry(0.3, 0 );
				let material = new THREE.MeshStandardMaterial( {  emissive: 0x6284FF } );
				let projects = [
					{	
						'project': 'wunderlist',
						'material': new THREE.MeshStandardMaterial( {  emissive: 0xd94d44 } ),
						'scale': Math.random() * 5 + 1
					},
					{
						'project': 'stickynotes',
						'material': new THREE.MeshStandardMaterial( {  emissive: 0xf5c54c } ),
						'scale': Math.random() * 4 + 1
					},
					{
						'project': 'secret',
						'material': new THREE.MeshStandardMaterial( {  emissive: 0x000000 } ),
						'scale': Math.random() * 2 + 1
					},
					{
						'project': 'photography',
						'material': new THREE.MeshStandardMaterial( {  emissive: 0x456d5f } ),
						'scale': Math.random() * 3 + 1
					},
					{
						'project': 'illustrations',
						'material': new THREE.MeshStandardMaterial( {  emissive: 0xfc7f51 } ),
						'scale': Math.random() * 2 + 1
					}, 
					{
						'project': 'knightlyrage',
						'material': new THREE.MeshStandardMaterial( {  emissive: 0xa9a6ac } ),
						'scale': Math.random() * 3 + 1
					}
				];

				for ( var i = 0; i < projects.length; i ++ ) {

					let mesh = new THREE.Mesh( geometry, projects[i].material );
					projects[i].material.shadowSide = THREE.DoubleSide;

					mesh.position.x = Math.random() * 10;
					mesh.position.y = Math.random() * 10;
					mesh.position.z = Math.random() * 10;
					mesh.callback = orbClick;
					mesh.projectTitle = projects[i].project;

					mesh.scale.x = mesh.scale.y = mesh.scale.z = projects[i].scale;

					scene.add( mesh );
					spheres.push( mesh );

					rotations.push([getRandomArbitrary(0.001,0.01),getRandomArbitrary(0.00001,0.0001)]);
				}

				//

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				container.appendChild( renderer.domElement );

				const width = window.innerWidth || 2;
				const height = window.innerHeight || 2;

				effect = new THREE.ParallaxBarrierEffect( renderer );
				effect.setSize( width, height );

				window.addEventListener( 'resize', onWindowResize, false );
				raycaster = new THREE.Raycaster();

				const directionalLight = new THREE.DirectionalLight( 0xcccccc, 0.1 );


				var ringGeometry = new THREE.RingGeometry( 0.3, 0.32, 6 );
				var ringMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
				ring = new THREE.Mesh( ringGeometry, ringMaterial );
				ring.scale.set(0.01,0.1,0.1);

				ring.title = 'cursor';
				scene.add( ring );
				scene.add( directionalLight );
				canvas = document.body.getElementsByTagName('canvas')[0];
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				effect.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( e ) {
				e.preventDefault();

				//for parallax 
				mouseX = ( e.clientX - windowHalfX ) / 100;
				mouseY = ( e.clientY - windowHalfY ) / 100;

				// for hover
				mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;

				mouse.x = (e.clientX / renderer.domElement.clientWidth) * 2 - 1;
				mouse.y =  - (e.clientY / renderer.domElement.clientHeight) * 2 + 1;
				
				raycaster.setFromCamera(mouse, camera);
		
				var intersects = raycaster.intersectObjects(spheres);
		
				if (intersects.length > 0) {
					canvas.style.cursor = "pointer";
				} 
				else {
					resetCursor();
					// this code moves the cursor on a 2d plane
					// var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
					// vector.unproject( camera );
					// var dir = vector.sub( camera.position ).normalize();

					// var distance = - camera.position.z / dir.z;
					// var pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
					// ring.position.copy(pos);
					ring.rotation.copy(camera.rotation);
				}
			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
			}

			function getRandomArbitrary(min, max) {
				return Math.random() * (max - min) + min;
			}

			function orbClick(obj) {
				console.log(obj)
			}

			function resetCursor() {
				ring.scale.set(0.01,0.1,0.1);
				if (canvas) canvas.style.cursor = "default";
			}

			function handleCursor () {
				const intersects = raycaster.intersectObjects( spheres );
				if ( intersects.length > 0 ) {
					let intersekt = intersects[0].object;

					const maxX = (intersekt.scale.x + 2).toFixed(2);
					const maxY = (intersekt.scale.y + 2).toFixed(2);
					const maxZ = (intersekt.scale.z + 2).toFixed(2);

					if (ring.scale.x.toFixed(2) <= maxX && ring.scale.y.toFixed(2) <= maxY && ring.scale.z.toFixed(2) <= maxZ) {
						ring.scale.x += 0.4;
						ring.scale.y += 0.4;
						ring.scale.z += 0.4;
					}
				
					ring.scale.set(ring.scale.x, ring.scale.y, ring.scale.z);
					ring.position.x = intersekt.position.x;
					ring.position.y = intersekt.position.y;
					ring.position.z = intersekt.position.z;
					ring.rotation.x += 0.01;
					ring.rotation.y += 0.01;
					ring.rotation.z += 0.01;
				}
			}

			function render() {

				var timer = 0.0001 * Date.now();

				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( mouseY - camera.position.y ) * .05;
				var hover;
				camera.lookAt( scene.position );

				for ( var i = 0, il = spheres.length; i < il; i ++ ) {

					var sphere = spheres[ i ];

					sphere.position.x = 5 * Math.cos( timer + i );
					sphere.position.y = 5 * Math.sin( timer + i * 1.1 );
					sphere.rotation.x += rotations[i][0];
					sphere.rotation.y += rotations[i][1];
				}

				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( scene.children );
				if ( intersects.length > 0 ) {
					if ( INTERSECTED != intersects[ 0 ].object && intersects[ 0 ].object.title !== 'cursor') {
						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						// INTERSECTED.material.emissive.setHex( 0xff0000 );
					}
				} else {
					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
					INTERSECTED = null;
					resetCursor()
				}
				
				handleCursor();

				effect.render( scene, camera );
			}

			function onMouseDown (e) {
				e.preventDefault();
				mouse.x = (e.clientX / renderer.domElement.clientWidth) * 2 - 1;
				mouse.y =  - (e.clientY / renderer.domElement.clientHeight) * 2 + 1;

				raycaster.setFromCamera(mouse, camera);
				var intersects = raycaster.intersectObjects(spheres);

				if (intersects.length > 0) {
					intersects[0].object.callback(intersects[0]);
				}
			}

			document.addEventListener('mousedown', onMouseDown, false);
		</script>


		<div class="sheet closed" id="wunderlist">

		</div> 
	</body>
</html>